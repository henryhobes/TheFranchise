# **ESPN Draft State Tracking & Management**

## **Objectives**

* Implement a robust **DraftState** system to accurately maintain the state of an ESPN fantasy draft in real-time. This includes creating a `DraftState` data structure (e.g. drafted players, available players, team rosters, current pick number, picks until next turn, clock, etc.) as outlined in the Sprint 1 plan[GitHub](https://github.com/henryhobes/TheFranchise/blob/61826e965192e96acf8b293554a7d5d5a31ddeb4/draftOps/docs/draftops-implementation-plan.md#L85-L93). The goal is to update this state **on each WebSocket event** (pick made, new team on clock, etc.) so that our internal representation mirrors the ESPN draft status without lag or corruption[GitHub](https://github.com/henryhobes/TheFranchise/blob/04eca3f828c65c10c55e0c5ed99f03bf7d47ca10/draftOps/docs/sprint-results/sprint-0-completion-summary.md#L2-L5). We will leverage the simplified text-based message protocol discovered in Sprint 0 to drive state updates efficiently (no complex JSON parsing needed). This provides the foundation for all higher-level logic in subsequent sprints by ensuring we always know the draft context accurately in real time[GitHub](https://github.com/henryhobes/TheFranchise/blob/04eca3f828c65c10c55e0c5ed99f03bf7d47ca10/draftOps/docs/sprint-results/sprint-0-completion-summary.md#L282-L288).

  ## **Scope**

* **In Scope:** Designing and implementing the `DraftState` class and its update mechanisms. This includes handling events like a player being selected (to update drafted player lists and team rosters), a new team going on the clock (updating current pick number, picks-until-next for our team, and timer), and any clock/timer updates relevant to draft state. The scope covers integrating the state updates with incoming WebSocket messages in the monitoring pipeline, and validating that state against the ESPN UI or data (e.g. ensuring our `DraftState` matches the official draft order and picks at all times).

* **Out of Scope:** AI-based decision logic or recommendations (those will come in later sprints once state tracking is solid). We are not persisting state to disk in this sprint (no database or resume capability yet – persistence and recovery will be addressed in production hardening). Handling multiple simultaneous drafts or users is beyond the current scope; we focus on one draft session at a time. Also, any **player ID to name resolution** beyond using the existing resolver is considered integration (the resolver itself was implemented in Sprint 0), so this spec will treat player IDs as the primary key for state (with names added for display via the resolver in the integration stage).

  ## **Deliverables**

* **DraftState Class Implementation:** A new `DraftState` Python class (or equivalent structure) defined with fields for all necessary draft state as specified in the plan[GitHub](https://github.com/henryhobes/TheFranchise/blob/61826e965192e96acf8b293554a7d5d5a31ddeb4/draftOps/docs/draftops-implementation-plan.md#L85-L93) – for example: `drafted_players` (set of player IDs taken), `available_players` (list or set of remaining player IDs), `my_roster` (our team’s roster by position), `current_pick` number (or overall pick count), `picks_until_next` (for our next turn calculation), `time_remaining` on the clock, and `on_the_clock` (which team or user is currently picking). This class will also include methods to apply updates (e.g. `apply_pick(player_id, team_id)`, `start_new_pick(pick_number, team_id, clock_ms)`, etc.).

* **Real-Time State Update Logic:** Integration of the `DraftState` with the incoming WebSocket event stream. On each relevant event (e.g. a “**SELECTED**” message indicating a pick made, or “**SELECTING**” indicating the next team is up), the system will parse the message and update the `DraftState` accordingly. For example, when a pick is made, we remove that player from `available_players`, add the player to the selecting team’s roster, increment the pick count, and possibly adjust `picks_until_next` for our team. When a new team goes on the clock, update `current_pick`, `on_the_clock` team, and reset `time_remaining` from the message (if provided). These updates happen within a few tens of milliseconds of receiving the WebSocket frame so that the state is immediately consistent with the draft events.

* **State Consistency Checks:** Basic validation mechanisms to ensure our state remains accurate. For instance, after each pick, the number of drafted players in our state should equal the pick number, and the last drafted player ID should match the one reported by ESPN. We will include assertions or logs for such conditions during development. By the end of Sprint 1, we expect to maintain state with **100% accuracy** vs the ESPN draft (no missing or extra players, correct team assignments), meeting the plan’s success criteria of state matching the ESPN UI at all times[GitHub](https://github.com/henryhobes/TheFranchise/blob/61826e965192e96acf8b293554a7d5d5a31ddeb4/draftOps/docs/draftops-implementation-plan.md#L126-L129).

  ## **Assumptions & Constraints**

* We assume the **WebSocket messages provide sufficient information** to update all necessary state. Sprint 0 analysis confirmed that messages like `SELECTED` and `SELECTING` carry at least the player ID, pick number or slot, and team info needed for state updates[GitHub](https://github.com/henryhobes/TheFranchise/blob/04eca3f828c65c10c55e0c5ed99f03bf7d47ca10/draftOps/docs/sprint-results/sprint-0-completion-summary.md#L25-L33)[GitHub](https://github.com/henryhobes/TheFranchise/blob/04eca3f828c65c10c55e0c5ed99f03bf7d47ca10/draftOps/docs/sprint-results/sprint-0-completion-summary.md#L48-L56). The protocol was simpler than expected (text commands), which we assume will remain stable; thus, we won’t need an elaborate schema mapper for JSON – simple string parsing will suffice for now. (If ESPN changes format later, we may adapt, but Sprint 1 proceeds with the current format.)

* Only **standard snake draft flows** are considered. We assume no unusual events like draft pauses, pick undo/redo, or trades affecting draft order occur during Sprint 1 development and testing. The system is built to handle the normal sequence of picks in order. Handling extraordinary cases or custom league rules is deferred or considered out of scope unless encountered during testing.

* **Single user/team focus:** For our purposes, `DraftState.my_roster` will track the team using DraftOps (our team) and we assume we know which team that is (likely via configuration or identifying the logged-in user’s team ID). We will require that information (team ID) when initializing the state. We also assume one draft is monitored at a time, so a single global state is maintained. Concurrency (multiple drafts or users) is not handled in this sprint.

* **No persistent storage** of state between sessions. The state exists in memory. If the program or connection restarts, we would need to reconstruct state from scratch or from ESPN data (reconstruction on reconnect is addressed in the connection spec). In Sprint 1, if a session is interrupted beyond a quick reconnect, the test will be restarted; long-term persistence comes later.

* **Performance:** Updating state is computationally trivial (set and dict updates, etc.), and we assume it can be done well under the 200ms target for real-time processing[GitHub](https://github.com/henryhobes/TheFranchise/blob/04eca3f828c65c10c55e0c5ed99f03bf7d47ca10/draftOps/docs/sprint-results/sprint-0-completion-summary.md#L2-L5). The main constraint is ensuring we do not introduce any blocking operations in the event loop when updating state. We will use asynchronous patterns appropriately so that state updates do not slow down message processing.

  ## **Milestones**

1. **Define DraftState Structure:** Create the `DraftState` class with all necessary fields and initial state setup. For example, prior to the draft start, initialize `drafted_players` as empty, `available_players` as a full list of players (from a pre-loaded pool, if available – possibly loaded via ESPN API for the league’s player list), `current_pick = 0` or None, `on_the_clock = None`, etc. Ensure this structure is easy to update and query. Review the fields against what the draft protocol provides to confirm completeness[GitHub](https://github.com/henryhobes/TheFranchise/blob/61826e965192e96acf8b293554a7d5d5a31ddeb4/draftOps/docs/draftops-implementation-plan.md#L85-L93).

2. **Implement Event Handlers for State Updates:** For each relevant WebSocket event type identified (from Sprint 0, e.g. `SELECTED`, `SELECTING`, `CLOCK`, etc.), write a handler that updates the DraftState. For instance:

   * On a **SELECTED** (pick made) event: parse the message to get player ID and team. Call a `draft_state.apply_pick(player_id, team_id)` that will add the player to `drafted_players`, remove from `available_players`, append to that team’s roster, and increment a pick counter or round/pick tracking as needed. Also, if the team is ours, reflect that in our roster count.

   * On a **SELECTING** (new on-clock) event: parse to get which pick number is starting and which team is up (and possibly clock time). Update `draft_state.current_pick` (or round/overall pick number) to this new pick, set `on_the_clock` to the team, reset `time_remaining` (e.g. 60 or 30 seconds as given). Calculate `picks_until_next` for our team: if our team’s next pick position is known (we can derive from league settings and current pick number), update this countdown.

   * On **CLOCK** (timer countdown) events: update `time_remaining` in state if such messages are sent periodically (e.g. 30s left). This might be optional if ESPN doesn’t send frequent clock updates (to be verified; if not, `time_remaining` can be updated via local timer or simply set at start of turn).

   * Handle any other relevant message (like “**ROSTER\_UPDATE**” if it exists separately, or “**AUTODRAFT**” notifications) that might affect state (rosters or picks).

3. **Integrate with Monitor Pipeline:** Work with the connection/monitor component so that whenever a WebSocket frame arrives, it triggers the appropriate state-update handler. For now, this can be done in a simple conditional way: e.g., if a frame’s text starts with `"SELECTED"` call the selected-handler, if `"SELECTING"` call the on-clock handler, etc. We will implement this in the overall event processing function (as per the plan’s outline for `process_websocket_frame`[GitHub](https://github.com/henryhobes/TheFranchise/blob/61826e965192e96acf8b293554a7d5d5a31ddeb4/draftOps/docs/draftops-implementation-plan.md#L105-L112)). Ensure this integration is non-blocking (use async if needed when, for example, resolving player names, though the state update itself is fast).

4. **Initial Testing – Controlled Environment:** Before full integration test, simulate a sequence of events to test state logic. For example, feed a series of synthetic events to the state handlers (possibly by reading a captured log from Sprint 0\) to verify that after a sequence of picks, the DraftState contains exactly the expected data. If possible, use one of the saved draft session logs (the JSON or HAR from Sprint 0\) to replay events through the state updater and assert that the final state matches the final picks from that session. This will help catch any parsing or update logic errors early.

5. **Live Testing – Mock Draft:** Run the monitoring system in a live ESPN mock draft and validate the state in real time. After a few rounds or a full draft, compare our `DraftState` with the draft results from ESPN:

   * Verify that the count of drafted players equals the pick number (e.g. after 15 picks, our state has 15 in `drafted_players`).

   * Spot-check that specific players picked (by name/ID) are present in the correct team’s roster in our state.

   * Ensure `picks_until_next` decrements correctly and reaches 0 when our pick is up (if we simulate being a particular team).

   * Check that `time_remaining` resets each round and roughly corresponds to expectations (though slight differences if we’re not perfectly synced to the clock tick are acceptable).  
      Any discrepancies will be noted and fixed. By the end of Sprint 1, the system should be able to **track a full mock draft end-to-end with no state errors**, satisfying the success criterion of no state corruption[GitHub](https://github.com/henryhobes/TheFranchise/blob/61826e965192e96acf8b293554a7d5d5a31ddeb4/draftOps/docs/draftops-implementation-plan.md#L13-L17).

6. **Documentation & Review:** Document how each message type affects the draft state (this could be in code comments or a short internal wiki for reference). Conduct a review (with team or self) to ensure the state management covers all needed aspects for the upcoming recommendation engine in Sprint 2\. For example, confirm that we can derive from `DraftState` all inputs that Sprint 2’s algorithms will need (like knowing which players are available, how many players each team has at each position, etc.). This future-proofing ensures our state tracking is comprehensive.
